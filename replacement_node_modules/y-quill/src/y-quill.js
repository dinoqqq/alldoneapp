/**
 * @module bindings/quill
 */

import { createMutex } from 'lib0/mutex.js'
import * as Y from 'yjs' // eslint-disable-line
import { Awareness } from 'y-protocols/awareness.js' // eslint-disable-line

/**
 * Removes the pending '\n's if it has no attributes.
 */
export const normQuillDelta = delta => {
    if (delta.length > 0) {
        const d = delta[delta.length - 1]
        const insert = d.insert
        if (d.attributes === undefined && insert !== undefined && insert.slice(-1) === '\n') {
            delta = delta.slice()
            let ins = insert.slice(0, -1)
            while (ins.slice(-1) === '\n') {
                ins = ins.slice(0, -1)
            }
            delta[delta.length - 1] = { insert: ins }
            if (ins.length === 0) {
                delta.pop()
            }
            return delta
        }
    }
    return delta
}

/**
 * @param {any} quillCursors
 */
const updateCursor = (quillCursors, aw, clientId, doc, type) => {
    try {
        if (aw && aw.cursor && clientId !== doc.clientID) {
            const user = aw.user || {}
            const color = user.color || '#ffa500'
            const name = user.name || `User: ${clientId}`
            quillCursors.createCursor(clientId.toString(), name, color)
            const anchor = Y.createAbsolutePositionFromRelativePosition(
                Y.createRelativePositionFromJSON(aw.cursor.anchor),
                doc
            )
            const head = Y.createAbsolutePositionFromRelativePosition(
                Y.createRelativePositionFromJSON(aw.cursor.head),
                doc
            )
            if (anchor && head && anchor.type === type) {
                quillCursors.moveCursor(clientId.toString(), { index: anchor.index, length: head.index - anchor.index })
            }
        } else {
            quillCursors.removeCursor(clientId.toString())
        }
    } catch (err) {
        console.error(err)
    }
}

export class QuillBinding {
    /**
     * @param {Y.Text} type
     * @param {any} quill
     * @param {Awareness} [awareness]
     */
    constructor(type, quill, awareness) {
        console.log('[BOLD_DEBUG] QuillBinding constructor called')
        const mux = createMutex()
        const doc = /** @type {Y.Doc} */ (type.doc)
        this.mux = mux
        this.type = type
        this.doc = doc
        this.quill = quill
        const quillCursors = quill.getModule('cursors') || null
        this.quillCursors = quillCursors
        // This object contains all attributes used in the quill instance
        this._negatedUsedFormats = {}
        this.awareness = awareness
        this._awarenessChange = ({ added, removed, updated }) => {
            const states = /** @type {Awareness} */ (awareness).getStates()
            added.forEach(id => {
                updateCursor(quillCursors, states.get(id), id, doc, type)
            })
            updated.forEach(id => {
                updateCursor(quillCursors, states.get(id), id, doc, type)
            })
            removed.forEach(id => {
                quillCursors.removeCursor(id.toString())
            })
        }
        this._typeObserver = event => {
            mux(() => {
                const eventDelta = event.delta
                console.log('[BOLD_DEBUG] _typeObserver: Yjs -> Quill update')
                console.log(
                    '[BOLD_DEBUG] _typeObserver: _negatedUsedFormats =',
                    JSON.stringify(this._negatedUsedFormats)
                )
                console.log(
                    '[BOLD_DEBUG] _typeObserver: eventDelta =',
                    JSON.stringify(
                        eventDelta.map(d => ({
                            ...d,
                            insert: typeof d.insert === 'string' ? d.insert.substring(0, 30) : d.insert,
                        }))
                    )
                )
                // We always explicitly set attributes, otherwise concurrent edits may
                // result in quill assuming that a text insertion shall inherit existing
                // attributes.
                const delta = []
                for (let i = 0; i < eventDelta.length; i++) {
                    const d = eventDelta[i]
                    if (d.insert !== undefined) {
                        const mergedAttrs = Object.assign({}, this._negatedUsedFormats, d.attributes || {})
                        console.log(
                            `[BOLD_DEBUG] _typeObserver: Op[${i}] original attrs =`,
                            JSON.stringify(d.attributes),
                            '-> merged attrs =',
                            JSON.stringify(mergedAttrs)
                        )
                        delta.push(
                            Object.assign({}, d, {
                                attributes: mergedAttrs,
                            })
                        )
                    } else {
                        delta.push(d)
                    }
                }
                console.log(
                    '[BOLD_DEBUG] _typeObserver: Final delta to Quill =',
                    JSON.stringify(
                        delta.map(d => ({
                            ...d,
                            insert: typeof d.insert === 'string' ? d.insert.substring(0, 30) : d.insert,
                        }))
                    )
                )
                quill.updateContents(delta, 'yjs')
            })
        }
        type.observe(this._typeObserver)
        this._quillObserver = (eventType, delta) => {
            if (delta && delta.ops) {
                // update content
                const ops = delta.ops
                console.log('[BOLD_DEBUG] _quillObserver: Quill -> Yjs update, eventType =', eventType)
                console.log(
                    '[BOLD_DEBUG] _quillObserver: ops =',
                    JSON.stringify(
                        ops.map(op => ({
                            ...op,
                            insert: typeof op.insert === 'string' ? op.insert.substring(0, 30) : op.insert,
                        }))
                    )
                )
                ops.forEach((op, index) => {
                    if (op.attributes !== undefined) {
                        console.log(
                            `[BOLD_DEBUG] _quillObserver: Op[${index}] has attributes:`,
                            JSON.stringify(op.attributes)
                        )
                        for (let key in op.attributes) {
                            if (this._negatedUsedFormats[key] === undefined) {
                                console.log(
                                    `[BOLD_DEBUG] _quillObserver: Adding new format key "${key}" to _negatedUsedFormats`
                                )
                                this._negatedUsedFormats[key] = false
                            }
                        }
                    }
                })
                console.log(
                    '[BOLD_DEBUG] _quillObserver: _negatedUsedFormats after update =',
                    JSON.stringify(this._negatedUsedFormats)
                )
                mux(() => {
                    // FIX: Yjs applyDelta() doesn't properly handle null attributes for format removal.
                    // See https://github.com/yjs/yjs/issues/474
                    // We need to manually call type.format() for retain ops with null attributes,
                    // as applyDelta() doesn't reliably remove attributes when set to null.

                    let currentIndex = 0
                    const opsWithoutNullFormats = []
                    const formatOps = [] // Collect format removal operations to apply after

                    for (let i = 0; i < ops.length; i++) {
                        const op = ops[i]

                        if (op.retain !== undefined && op.attributes) {
                            // Check if any attributes are null (format removal)
                            const nullAttrs = {}
                            const nonNullAttrs = {}
                            let hasNullAttrs = false
                            let hasNonNullAttrs = false

                            for (const key in op.attributes) {
                                if (op.attributes[key] === null) {
                                    nullAttrs[key] = null
                                    hasNullAttrs = true
                                } else {
                                    nonNullAttrs[key] = op.attributes[key]
                                    hasNonNullAttrs = true
                                }
                            }

                            if (hasNullAttrs) {
                                console.log(
                                    `[BOLD_DEBUG] _quillObserver: Found null attrs at index ${currentIndex}, length ${op.retain}:`,
                                    JSON.stringify(nullAttrs)
                                )
                                // Store format removal operation to apply explicitly
                                formatOps.push({
                                    index: currentIndex,
                                    length: op.retain,
                                    attributes: nullAttrs,
                                })

                                // If there are also non-null attrs, keep them in the delta
                                if (hasNonNullAttrs) {
                                    opsWithoutNullFormats.push({
                                        retain: op.retain,
                                        attributes: nonNullAttrs,
                                    })
                                } else {
                                    // Just retain without attributes
                                    opsWithoutNullFormats.push({ retain: op.retain })
                                }
                            } else {
                                // No null attrs, keep as-is
                                opsWithoutNullFormats.push(op)
                            }
                            currentIndex += op.retain
                        } else if (op.retain !== undefined) {
                            opsWithoutNullFormats.push(op)
                            currentIndex += op.retain
                        } else if (op.insert !== undefined) {
                            opsWithoutNullFormats.push(op)
                            const insertLength = typeof op.insert === 'string' ? op.insert.length : 1
                            currentIndex += insertLength
                        } else if (op.delete !== undefined) {
                            opsWithoutNullFormats.push(op)
                            // delete doesn't advance the index in the same way
                        } else {
                            opsWithoutNullFormats.push(op)
                        }
                    }

                    // Apply the delta without the null format operations
                    if (opsWithoutNullFormats.length > 0) {
                        console.log(
                            '[BOLD_DEBUG] _quillObserver: Applying opsWithoutNullFormats:',
                            JSON.stringify(
                                opsWithoutNullFormats.map(op => ({
                                    ...op,
                                    insert: typeof op.insert === 'string' ? op.insert.substring(0, 30) : op.insert,
                                }))
                            )
                        )
                        type.applyDelta(opsWithoutNullFormats)
                    }

                    // Now explicitly apply format removals using type.format()
                    // This ensures null attributes actually remove the formatting
                    for (const formatOp of formatOps) {
                        console.log(
                            `[BOLD_DEBUG] _quillObserver: Applying format removal at index ${formatOp.index}, length ${formatOp.length}:`,
                            JSON.stringify(formatOp.attributes)
                        )
                        type.format(formatOp.index, formatOp.length, formatOp.attributes)
                    }

                    // Verify the result
                    if (formatOps.length > 0) {
                        const resultDelta = type.toDelta()
                        const boldOps = resultDelta.filter(op => op.attributes && op.attributes.bold)
                        console.log(
                            '[BOLD_DEBUG] _quillObserver: After format removal, Y.Text has',
                            boldOps.length,
                            'ops with bold=true'
                        )
                    }
                })
            }
            // always check selection
            if (awareness && quillCursors) {
                const sel = quill.getSelection()
                const aw = /** @type {any} */ (awareness.getLocalState())
                if (sel === null) {
                    if (awareness.getLocalState() !== null) {
                        awareness.setLocalStateField('cursor', /** @type {any} */ (null))
                    }
                } else {
                    const anchor = Y.createRelativePositionFromTypeIndex(type, sel.index)
                    const head = Y.createRelativePositionFromTypeIndex(type, sel.index + sel.length)
                    if (
                        !aw ||
                        !aw.cursor ||
                        !Y.compareRelativePositions(anchor, aw.cursor.anchor) ||
                        !Y.compareRelativePositions(head, aw.cursor.head)
                    ) {
                        awareness.setLocalStateField('cursor', {
                            anchor,
                            head,
                        })
                    }
                }
                // update all remote cursor locations
                awareness.getStates().forEach((aw, clientId) => {
                    updateCursor(quillCursors, aw, clientId, doc, type)
                })
            }
        }
        quill.on('editor-change', this._quillObserver)
        // Pre-populate _negatedUsedFormats from the existing document content.
        // This ensures that when setContents is called, all format keys used anywhere
        // in the document are already known, so unformatted text gets explicit
        // negations (e.g. bold: false) preventing format inheritance/bleed.
        const initialDelta = type.toDelta()
        console.log('[BOLD_DEBUG] QuillBinding init: Processing initialDelta from Y.Text')
        console.log('[BOLD_DEBUG] QuillBinding init: initialDelta length =', initialDelta.length)
        for (let i = 0; i < initialDelta.length; i++) {
            const attrs = initialDelta[i].attributes
            const insertText =
                typeof initialDelta[i].insert === 'string' ? initialDelta[i].insert.substring(0, 30) : '[embed]'
            if (attrs) {
                console.log(
                    `[BOLD_DEBUG] QuillBinding init: Op[${i}] "${insertText}" has attrs =`,
                    JSON.stringify(attrs)
                )
                for (const key in attrs) {
                    if (this._negatedUsedFormats[key] === undefined) {
                        console.log(`[BOLD_DEBUG] QuillBinding init: Adding format key "${key}" to _negatedUsedFormats`)
                        this._negatedUsedFormats[key] = false
                    }
                }
            } else {
                console.log(`[BOLD_DEBUG] QuillBinding init: Op[${i}] "${insertText}" has NO attrs`)
            }
        }
        console.log(
            '[BOLD_DEBUG] QuillBinding init: Final _negatedUsedFormats =',
            JSON.stringify(this._negatedUsedFormats)
        )
        console.log('[BOLD_DEBUG] QuillBinding init: Calling quill.setContents(initialDelta)')
        mux(() => {
            quill.setContents(initialDelta)
        })
        console.log('[BOLD_DEBUG] QuillBinding init: setContents complete')
        // init remote cursors
        if (quillCursors !== null && awareness) {
            awareness.getStates().forEach((aw, clientId) => {
                updateCursor(quillCursors, aw, clientId, doc, type)
            })
            awareness.on('change', this._awarenessChange)
        }
    }
    destroy() {
        this.type.unobserve(this._typeObserver)
        this.quill.off('editor-change', this._quillObserver)
        if (this.awareness) {
            this.awareness.off('change', this._awarenessChange)
        }
    }
}
